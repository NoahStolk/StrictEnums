# StrictEnums
 
Provides a different way to declare enums in C#. Enum members are declared as static fields on a class. Boilerplate code will be generated.

This also enables the developer to directly implement methods for any enum type, instead of having to use extension methods.

## IMPORTANT

This library is in very early development. Currently, only `int` is supported as enum type. Also note that this library makes use of static abstract members in interfaces, which is a preview feature. Any consuming project would need to enable preview features:

```xml
<EnablePreviewFeatures>true</EnablePreviewFeatures>
<LangVersion>preview</LangVersion>
```

## Example

Original enum:
```cs
public enum ExampleEnum : int
{
	Value1 = 1,
	Value2 = 2,
	Value3 = 3,
	Value4 = 4,
}
```

Strict enum:
```cs
public partial class ExampleEnum : IStrictEnum<int, ExampleEnum>
{
	public static readonly ExampleEnum Value1 = new(1);
	public static readonly ExampleEnum Value2 = new(2);
	public static readonly ExampleEnum Value3 = new(3);
	public static readonly ExampleEnum Value4 = new(4);
	
	// Not relying on "enum" itself makes it possible to declare methods directly rather than via an extension method.
	public int GetValueMultiplied(int multiplier)
	{
		return Value * multiplier;
	}
}
```

Generated code:
```cs
// <auto-generated />

public partial class ExampleEnum
{
	private ExampleEnum(int value)
	{
		Value = value;
	}

	public int Value { get; }

	public static ExampleEnum ConvertFrom(int value) => value switch
	{
		1 => Value1,
		2 => Value2,
		3 => Value3,
		4 => Value4,
		_ => throw new InvalidOperationException($"Impossible value {value} for {nameof(ExampleEnum)}."),
	};

	public override string ToString() => Value switch
	{
		1 => nameof(Value1),
		2 => nameof(Value2),
		3 => nameof(Value3),
		4 => nameof(Value4),
		_ => throw new InvalidOperationException($"Impossible value {Value} for {nameof(ExampleEnum)}."),
	};
}
```

## Viewing generated code

In order to view the code generated by the source generator, you need to put this in the consuming project's `.csproj` file:

```xml
<!--Emit generated code to a path in the obj directory, so it is ignored by Git (or should be)-->
<PropertyGroup>
	<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
	<CompilerGeneratedFilesOutputPath>obj\SourceGenOutput</CompilerGeneratedFilesOutputPath>
</PropertyGroup>

<ItemGroup>
	<!--Remove the generated files from the compilation, otherwise the code is included twice which creates build errors-->
	<Compile Remove="$(CompilerGeneratedFilesOutputPath)/**/*.cs" />
	<!--Include the generated files so they can be viewed in the IDE-->
	<None Include="$(CompilerGeneratedFilesOutputPath)/**/*.cs" />
</ItemGroup>
```

This will emit all generated code for the project to the `obj\SourceGenOutput` directory.
